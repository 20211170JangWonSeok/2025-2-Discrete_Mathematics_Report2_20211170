# ì´ì‚°ìˆ˜í•™ Report2 20211170

# ======================================================================
# Report 2 : ê´€ê³„ í–‰ë ¬ì„ ì´ìš©í•œ ë™ì¹˜ ê´€ê³„ íŒë³„ ë° ë™ì¹˜ë¥˜/íí¬/ì—°ê²° ê´€ê³„ í”„ë¡œê·¸ë¨
#   1ë‹¨ê³„: ê´€ê³„ í–‰ë ¬ ì…ë ¥
#   2ë‹¨ê³„: ë°˜ì‚¬/ëŒ€ì¹­/ì¶”ì´ ì—¬ë¶€ íŒë³„ (ë™ì¹˜ ê´€ê³„ì¸ì§€ í™•ì¸)
#   3ë‹¨ê³„: ë™ì¹˜ ê´€ê³„ì¼ ê²½ìš° ë™ì¹˜ë¥˜ ì¶œë ¥
#   4ë‹¨ê³„: ë™ì¹˜ê°€ ì•„ë‹ ê²½ìš° í•„ìš”í•œ íí¬ë§Œ ì ìš©í•˜ì—¬ ë™ì¹˜ ê´€ê³„ë¡œ ë³€í™˜
#   5ë‹¨ê³„(ì¶”ê°€ê¸°ëŠ¥): Warshall ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ
#       "ì…ë ¥ë°›ì€ ì›ë˜ ê´€ê³„ í–‰ë ¬"ì— ëŒ€í•´ ì—°ê²° ê´€ê³„(ë„ë‹¬ ê°€ëŠ¥ì„±) ë¶„ì„
# ======================================================================

# -------------------------------------------------------------
# [ê³µí†µ] ì§‘í•© A ì •ì˜
# -------------------------------------------------------------
A = [1, 2, 3, 4, 5]


# -------------------------------------------------------------
# 2ë‹¨ê³„: ë™ì¹˜ ê´€ê³„ íŒë³„ìš© í•¨ìˆ˜ë“¤
# -------------------------------------------------------------
def is_reflexive(R):
    """ë°˜ì‚¬ì„± ê²€ì‚¬: ëª¨ë“  iì— ëŒ€í•´ R[i][i] == 1 ì´ì–´ì•¼ í•¨"""
    for i in range(5):
        if R[i][i] != 1:
            return False
    return True


def is_symmetric(R):
    """ëŒ€ì¹­ì„± ê²€ì‚¬: ëª¨ë“  i, j ì— ëŒ€í•´ R[i][j] == R[j][i] ì´ì–´ì•¼ í•¨"""
    for i in range(5):
        for j in range(5):
            if R[i][j] != R[j][i]:
                return False
    return True


def is_transitive(R):
    """ì¶”ì´ì„± ê²€ì‚¬: R[i][j] = 1, R[j][k] = 1 ì´ë©´ R[i][k]ë„ 1ì´ì–´ì•¼ í•¨"""
    for i in range(5):
        for j in range(5):
            if R[i][j] == 1:
                for k in range(5):
                    if R[j][k] == 1 and R[i][k] != 1:
                        return False
    return True


# -------------------------------------------------------------
# 3ë‹¨ê³„: ë™ì¹˜ë¥˜ ê³„ì‚° í•¨ìˆ˜
# -------------------------------------------------------------
def equivalence_class(R, x):
    """ì›ì†Œ xì˜ ë™ì¹˜ë¥˜ [x] ë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜"""
    eq_class = []
    idx = x - 1  # ì§‘í•© Aì˜ ê°’(1~5)ì„ í–‰ë ¬ ì¸ë±ìŠ¤(0~4)ë¡œ ë³€í™˜
    for j in range(5):
        if R[idx][j] == 1:
            eq_class.append(A[j])
    return eq_class


# -------------------------------------------------------------
# 4ë‹¨ê³„: íí¬ í•¨ìˆ˜ë“¤ (ë°˜ì‚¬ / ëŒ€ì¹­ / ì¶”ì´)
# -------------------------------------------------------------
def reflexive_closure(R):
    """ë°˜ì‚¬ íí¬: ëŒ€ê° ì„±ë¶„ì„ ëª¨ë‘ 1ë¡œ ë§Œë“¤ì–´ ë°˜ì‚¬ì„± ë§Œì¡±"""
    new_R = [row[:] for row in R]
    for i in range(5):
        new_R[i][i] = 1
    return new_R


def symmetric_closure(R):
    """ëŒ€ì¹­ íí¬: (i, j)ê°€ 1ì´ë©´ (j, i)ë„ 1ë¡œ ë§Œë“¤ì–´ ëŒ€ì¹­ì„± ë§Œì¡±"""
    new_R = [row[:] for row in R]
    for i in range(5):
        for j in range(5):
            if R[i][j] == 1:
                new_R[j][i] = 1
    return new_R


def transitive_closure(R):
    """ì¶”ì´ íí¬: Warshall ë°©ì‹ìœ¼ë¡œ ëª¨ë“  ê²½ë¡œë¥¼ ì§ì ‘ ì—°ê²°"""
    new_R = [row[:] for row in R]
    for k in range(5):
        for i in range(5):
            for j in range(5):
                if new_R[i][k] == 1 and new_R[k][j] == 1:
                    new_R[i][j] = 1
    return new_R


def print_matrix(M):
    """í–‰ë ¬ì„ ë³´ê¸° ì¢‹ê²Œ ì¶œë ¥"""
    for row in M:
        print(row)
    print()


# -------------------------------------------------------------
# 5ë‹¨ê³„(ì¶”ê°€ê¸°ëŠ¥): Warshall ì—°ê²° ê´€ê³„ + ë‹¨ê³„ë³„ ê²½ë¡œ ì¶œë ¥
#   â€» í•­ìƒ "ì…ë ¥ë°›ì€ ì›ë˜ ê´€ê³„ í–‰ë ¬(relation)"ë§Œ ëŒ€ìƒìœ¼ë¡œ ë¶„ì„
# -------------------------------------------------------------
def warshall_connectivity_with_trace(R):
    """
    Warshall ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì—°ê²° ê´€ê³„(Reachability)ë¥¼ êµ¬í•˜ê³ 
    - ì›ë˜ í–‰ë ¬
    - ë‹¨ê³„ë³„ë¡œ ìƒˆë¡œ ì¶”ê°€ë˜ëŠ” ê²½ë¡œ
    - ìµœì¢… ì—°ê²° ê´€ê³„ í–‰ë ¬
    ì„ ì¶œë ¥í•œë‹¤.
    """
    n = 5
    C = [row[:] for row in R]

    print("ì›ë˜ì˜ ê´€ê³„ í–‰ë ¬:")
    print_matrix(C)

    print("ğŸ”· ë‹¨ê³„ë³„ ì¶”ê°€ ê²½ë¡œ:")

    added_any = False  # ì‹¤ì œë¡œ ì¶”ê°€ëœ ê²½ë¡œê°€ ìˆì—ˆëŠ”ì§€ ì—¬ë¶€ ì²´í¬

    for k in range(n):
        for i in range(n):
            for j in range(n):
                if C[i][j] == 0 and C[i][k] == 1 and C[k][j] == 1:
                    print(f"ë‹¨ê³„ k={k+1}: {A[i]} â†’ {A[k]} â†’ {A[j]} ê²½ë¡œê°€ ì¶”ê°€ë¨")
                    C[i][j] = 1
                    added_any = True

    if not added_any:
        print("ì¶”ê°€ë˜ëŠ” ê²½ë¡œê°€ ì—†ìŠµë‹ˆë‹¤. (ì´ë¯¸ ì£¼ì–´ì§„ ê²½ë¡œë§Œìœ¼ë¡œ ì¶©ë¶„í•œ ì—°ê²° ìƒíƒœì…ë‹ˆë‹¤.)")

    print()
    print("ìµœì¢… ì—°ê²°ê´€ê³„ í–‰ë ¬:")
    print_matrix(C)

    return C


def print_connectivity_info(R, title):
    """ì¶”ê°€ê¸°ëŠ¥ ì „ì²´ ì¶œë ¥ ë˜í¼ (í•­ìƒ ì›ë˜ ì…ë ¥ í–‰ë ¬ ê¸°ì¤€ ë¶„ì„)"""
    print("==================================================")
    print("[ì¶”ê°€ê¸°ëŠ¥] Warshall ì•Œê³ ë¦¬ì¦˜ì„ ì´ìš©í•œ ì—°ê²° ê´€ê³„ ë¶„ì„")
    print(f"ëŒ€ìƒ ê´€ê³„ : {title}")
    print("==================================================\n")
    warshall_connectivity_with_trace(R)


# -------------------------------------------------------------
# main í•¨ìˆ˜
# -------------------------------------------------------------
def main():
    # =========================================================
    # 1ë‹¨ê³„: ê´€ê³„ í–‰ë ¬ ì…ë ¥
    # =========================================================
    relation = []

    print("5Ã—5 ê´€ê³„ í–‰ë ¬ì„ ì…ë ¥í•˜ì„¸ìš” (ê° í–‰ì€ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„):")
    for i in range(5):
        row = list(map(int, input(f"{i+1}ë²ˆì§¸ í–‰ ì…ë ¥: ").split()))
        relation.append(row)

    # =========================================================
    # 2ë‹¨ê³„: ë™ì¹˜ ê´€ê³„ íŒë³„
    # =========================================================
    ref = is_reflexive(relation)
    sym = is_symmetric(relation)
    tra = is_transitive(relation)

    print("\n[ ê´€ê³„ ì„±ì§ˆ íŒë³„ ê²°ê³¼ ]")
    print(f"ë°˜ì‚¬ì„± : {ref}")
    print(f"ëŒ€ì¹­ì„± : {sym}")
    print(f"ì¶”ì´ì„± : {tra}")

    # =========================================================
    # 5ë‹¨ê³„(ì¶”ê°€ê¸°ëŠ¥): ì›ë˜ ì…ë ¥ í–‰ë ¬ì— ëŒ€í•´ Warshall ë¶„ì„
    #   â†’ í•­ìƒ "ì…ë ¥ë°›ì€ ì›ë˜ relation" ê¸°ì¤€ìœ¼ë¡œë§Œ ì‹¤í–‰
    # =========================================================
    print_connectivity_info(relation, "ì…ë ¥ëœ ì›ë˜ ê´€ê³„")

    # =========================================================
    # 3ë‹¨ê³„: ì´ë¯¸ ë™ì¹˜ ê´€ê³„ì¸ ê²½ìš°
    # =========================================================
    if ref and sym and tra:
        print("â†’ ì´ ê´€ê³„ëŠ” ì´ë¯¸ ë°˜ì‚¬Â·ëŒ€ì¹­Â·ì¶”ì´ì„±ì„ ëª¨ë‘ ë§Œì¡±í•˜ë¯€ë¡œ íí¬ë¥¼ ì ìš©í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.\n")
        print("[ ê° ì›ì†Œì˜ ë™ì¹˜ë¥˜ ]")
        for x in A:
            print(f"{x}ì˜ ë™ì¹˜ë¥˜ : {equivalence_class(relation, x)}")
        print()
        return  # ì—¬ê¸°ì„œ í”„ë¡œê·¸ë¨ ì¢…ë£Œ

    else:
        print("â†’ ì´ ê´€ê³„ëŠ” ë™ì¹˜ ê´€ê³„ê°€ ì•„ë‹ˆë¯€ë¡œ í•„ìš”í•œ íí¬ ë³€í™˜ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.\n")

    # =========================================================
    # 4ë‹¨ê³„: í•„ìš”í•œ íí¬ë§Œ ì ìš©
    # =========================================================
    print("------------- íí¬ ìƒì„± ê³¼ì • -------------\n")

    R_current = [row[:] for row in relation]

    # (1) ë°˜ì‚¬ íí¬: ë°˜ì‚¬ì„±ì´ ê¹¨ì ¸ ìˆì„ ë•Œë§Œ ì ìš©
    if not ref:
        print("[ë°˜ì‚¬ íí¬ ì „]")
        print_matrix(R_current)
        R_current = reflexive_closure(R_current)
        print("[ë°˜ì‚¬ íí¬ í›„]")
        print_matrix(R_current)
    else:
        print("[ë°˜ì‚¬ íí¬] ì´ë¯¸ ë°˜ì‚¬ì„±ì„ ë§Œì¡±í•˜ë¯€ë¡œ ë°˜ì‚¬ íí¬ëŠ” ìƒëµí•©ë‹ˆë‹¤.\n")

    # (2) ëŒ€ì¹­ íí¬: ëŒ€ì¹­ì„±ì´ ê¹¨ì ¸ ìˆì„ ë•Œë§Œ ì ìš©
    applied_sym_closure = False
    if not sym:
        print("[ëŒ€ì¹­ íí¬ ì „]")
        print_matrix(R_current)
        R_current = symmetric_closure(R_current)
        applied_sym_closure = True
        print("[ëŒ€ì¹­ íí¬ í›„]")
        print_matrix(R_current)
    else:
        print("[ëŒ€ì¹­ íí¬] ì´ë¯¸ ëŒ€ì¹­ì„±ì„ ë§Œì¡±í•˜ë¯€ë¡œ ëŒ€ì¹­ íí¬ëŠ” ìƒëµí•©ë‹ˆë‹¤.\n")

    # (3) ì¶”ì´ íí¬:
    #   - ì²˜ìŒë¶€í„° ì¶”ì´ì„±ì´ ê¹¨ì ¸ ìˆë˜ ê²½ìš°
    #   - ë˜ëŠ” 'ëŒ€ì¹­ íí¬'ë¥¼ ì ìš©í•´ì„œ ìƒˆ ê´€ê³„ê°€ ìƒê¸´ ê²½ìš°
    need_transitive_closure = (not tra) or applied_sym_closure

    if need_transitive_closure:
        print("[ì¶”ì´ íí¬ ì „]")
        print_matrix(R_current)
        R_current = transitive_closure(R_current)
        print("[ì¶”ì´ íí¬ í›„]")
        print_matrix(R_current)
    else:
        print("[ì¶”ì´ íí¬] ì´ë¯¸ ì¶”ì´ì„±ì„ ë§Œì¡±í•˜ë©° ëŒ€ì¹­ íí¬ë„ ì ìš©í•˜ì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ ì¶”ì´ íí¬ëŠ” ìƒëµí•©ë‹ˆë‹¤.\n")

    # íí¬ ì ìš© í›„ ìµœì¢… ê´€ê³„
    R_final = R_current

    print("[íí¬ ì ìš© í›„ ìµœì¢… ê´€ê³„ í–‰ë ¬]")
    print_matrix(R_final)

    # ìµœì¢… ë™ì¹˜ ê´€ê³„ íŒë³„
    print("[ìµœì¢… ë™ì¹˜ ê´€ê³„ íŒë³„]")
    final_ref = is_reflexive(R_final)
    final_sym = is_symmetric(R_final)
    final_tra = is_transitive(R_final)
    print(f"ë°˜ì‚¬ì„±: {final_ref}")
    print(f"ëŒ€ì¹­ì„±: {final_sym}")
    print(f"ì¶”ì´ì„±: {final_tra}")

    if final_ref and final_sym and final_tra:
        print("â†’ íí¬ ë³€í™˜ì„ í†µí•´ ë™ì¹˜ ê´€ê³„ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤.\n")
        print("[ìµœì¢… ê´€ê³„ì˜ ë™ì¹˜ë¥˜]")
        for x in A:
            print(f"{x}ì˜ ë™ì¹˜ë¥˜ : {equivalence_class(R_final, x)}")
        print()
    else:
        print("â†’ íí¬ë¥¼ ì ìš©í–ˆìŒì—ë„ ì•„ì§ ë™ì¹˜ ê´€ê³„ê°€ ì•„ë‹™ë‹ˆë‹¤.\n")


# -------------------------------------------------------------
# ì‹¤ì œ ì‹¤í–‰ ì‹œì‘ ì§€ì 
# -------------------------------------------------------------
if __name__ == "__main__":
    main()
